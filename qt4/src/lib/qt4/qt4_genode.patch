diff --git a/include/QtCore/qconfig.h b/include/QtCore/qconfig.h
--- a/include/QtCore/qconfig.h
+++ b/include/QtCore/qconfig.h
@@ -1,1 +1,1 @@
-#include "../../src/corelib/global/qconfig.h"
+#include "../../../src/corelib/global/qconfig.h"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/Collector.cpp
@@ -62,6 +62,13 @@
 
 #include <OS.h>
 
+#elif OS(GENODE)
+
+#include <base/printf.h>
+#include <base/stdint.h>
+#include <util/misc_math.h>
+#include <thread_qt.h>
+
 #elif OS(UNIX)
 
 #include <stdlib.h>
@@ -207,6 +214,15 @@
     void* address = _aligned_malloc(BLOCK_SIZE, BLOCK_SIZE);
 #endif
     memset(address, 0, BLOCK_SIZE);
+#elif OS(GENODE)
+    void* real_address = malloc(sizeof(Genode::addr_t) + BLOCK_SIZE + BLOCK_SIZE);
+    Genode::addr_t address = reinterpret_cast<Genode::addr_t>(real_address);
+    address += sizeof(Genode::addr_t);
+    address = Genode::align_addr(address, Genode::log2(BLOCK_SIZE));
+    address -= sizeof(Genode::addr_t);
+    *(Genode::addr_t*)address = (Genode::addr_t)real_address;
+    address += sizeof(Genode::addr_t);
+    memset(reinterpret_cast<void*>(address), 0, BLOCK_SIZE);
 #elif HAVE(POSIX_MEMALIGN)
     void* address;
     posix_memalign(&address, BLOCK_SIZE, BLOCK_SIZE);
@@ -297,6 +313,9 @@
 #else
     _aligned_free(block);
 #endif
+#elif OS(GENODE)
+    void *real_address = (void*)*(Genode::addr_t*)((Genode::addr_t)block - sizeof(Genode::addr_t));
+    free(real_address);
 #elif HAVE(POSIX_MEMALIGN)
     free(block);
 #else
@@ -638,6 +657,8 @@
     thread_info threadInfo;
     get_thread_info(find_thread(NULL), &threadInfo);
     return threadInfo.stack_end;
+#elif OS(GENODE)
+    return Genode::Thread_qt::myself()->stack_top();
 #elif OS(UNIX)
     AtomicallyInitializedStatic(Mutex&, mutex = *new Mutex);
     MutexLocker locker(mutex);
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/FastMalloc.cpp
@@ -97,7 +97,7 @@
 
 // Use a background thread to periodically scavenge memory to release back to the system
 // https://bugs.webkit.org/show_bug.cgi?id=27900: don't turn this on for Tiger until we have figured out why it caused a crash.
-#if defined(BUILDING_ON_TIGER)
+#if defined(BUILDING_ON_TIGER) || OS(GENODE)
 #define USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY 0
 #else
 #define USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY 1
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/Platform.h
@@ -454,6 +454,13 @@
 #define WTF_OS_UNIX 1
 #endif
 
+/* OS(GENODE) */
+/* Operating system level dependencies for Genode that should */
+/* be used regardless of operating environment */
+#ifdef __GENODE__
+#define WTF_OS_GENODE 1
+#endif
+
 /* Operating environments */
 
 /* FIXME: these are all mixes of OS, operating environment and policy choices. */
@@ -684,13 +691,13 @@
 #endif
 #endif /* !defined(HAVE_ACCESSIBILITY) */
 
-#if OS(UNIX) && !OS(SYMBIAN)
+#if OS(UNIX) && !OS(SYMBIAN) && !OS(GENODE)
 #define HAVE_SIGNAL_H 1
 #endif
 
 #if !OS(WINDOWS) && !OS(SOLARIS) && !OS(QNX) \
     && !OS(SYMBIAN) && !OS(HAIKU) && !OS(RVCT) \
-    && !OS(ANDROID) && !OS(AIX) && !OS(HPUX)
+    && !OS(ANDROID) && !OS(AIX) && !OS(HPUX) && !OS(GENODE)
 #define HAVE_TM_GMTOFF 1
 #define HAVE_TM_ZONE 1
 #define HAVE_TIMEGM 1
@@ -765,6 +772,12 @@
 #define HAVE_SYS_PARAM_H 1
 #define HAVE_SYS_TIME_H 1
 
+#elif OS(GENODE)
+
+#define HAVE_MMAP 0
+#define HAVE_SBRK 0
+#define HAVE_SYS_TIME_H 1
+
 #else
 
 /* FIXME: is this actually used or do other platforms generate their own config.h? */
@@ -915,7 +928,7 @@
 #elif CPU(X86) && OS(WINDOWS) && COMPILER(MSVC)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_REGISTER 1
-#elif CPU(X86) && OS(LINUX) && GCC_VERSION >= 40100
+#elif CPU(X86) && OS(LINUX) && GCC_VERSION >= 40100 && !OS(GENODE)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_VA_LIST 1
 #elif CPU(X86_64) && OS(LINUX) && GCC_VERSION >= 40100
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TCSystemAlloc.cpp
@@ -56,6 +56,12 @@
 #include <sys/mman.h>
 #endif
 
+#if OS(GENODE)
+#include <base/printf.h>
+#include <base/stdint.h>
+#include <util/misc_math.h>
+#endif
+
 #ifndef MAP_ANONYMOUS
 #define MAP_ANONYMOUS MAP_ANON
 #endif
@@ -379,6 +385,21 @@
     }
 #endif
 
+#if OS(GENODE)
+    if (actual_size)
+      *actual_size = size;
+
+    void* real_address = malloc(sizeof(Genode::addr_t) + size + alignment);
+    Genode::addr_t address = reinterpret_cast<Genode::addr_t>(real_address);
+    address += sizeof(Genode::addr_t);
+    address = Genode::align_addr(address, Genode::log2(alignment));
+    address -= sizeof(Genode::addr_t);
+    *(Genode::addr_t*)address = (Genode::addr_t)real_address;
+    address += sizeof(Genode::addr_t);
+
+    return (void*)address;;
+#endif
+
     // nothing worked - reset failure flags and try again
     devmem_failure = false;
     sbrk_failure = false;
diff --git a/src/3rdparty/webkit/JavaScriptCore/runtime/Collector.cpp b/src/3rdparty/webkit/JavaScriptCore/runtime/Collector.cpp
--- a/src/3rdparty/webkit/JavaScriptCore/runtime/Collector.cpp
+++ b/src/3rdparty/webkit/JavaScriptCore/runtime/Collector.cpp
@@ -62,6 +62,13 @@
 
 #include <OS.h>
 
+#elif OS(GENODE)
+
+#include <base/printf.h>
+#include <base/stdint.h>
+#include <util/misc_math.h>
+#include <thread_qt.h>
+
 #elif OS(UNIX)
 
 #include <stdlib.h>
@@ -207,6 +214,15 @@
     void* address = _aligned_malloc(BLOCK_SIZE, BLOCK_SIZE);
 #endif
     memset(address, 0, BLOCK_SIZE);
+#elif OS(GENODE)
+    void* real_address = malloc(sizeof(Genode::addr_t) + BLOCK_SIZE + BLOCK_SIZE);
+    Genode::addr_t address = reinterpret_cast<Genode::addr_t>(real_address);
+    address += sizeof(Genode::addr_t);
+    address = Genode::align_addr(address, Genode::log2(BLOCK_SIZE));
+    address -= sizeof(Genode::addr_t);
+    *(Genode::addr_t*)address = (Genode::addr_t)real_address;
+    address += sizeof(Genode::addr_t);
+    memset(reinterpret_cast<void*>(address), 0, BLOCK_SIZE);
 #elif HAVE(POSIX_MEMALIGN)
     void* address;
     posix_memalign(&address, BLOCK_SIZE, BLOCK_SIZE);
@@ -297,6 +313,9 @@
 #else
     _aligned_free(block);
 #endif
+#elif OS(GENODE)
+    void *real_address = (void*)*(Genode::addr_t*)((Genode::addr_t)block - sizeof(Genode::addr_t));
+    free(real_address);
 #elif HAVE(POSIX_MEMALIGN)
     free(block);
 #else
@@ -579,6 +598,8 @@
     thread_info threadInfo;
     get_thread_info(find_thread(NULL), &threadInfo);
     return threadInfo.stack_end;
+#elif OS(GENODE)
+   return Genode::Thread_qt::myself()->stack_top();
 #elif OS(UNIX)
     AtomicallyInitializedStatic(Mutex&, mutex = *new Mutex);
     MutexLocker locker(mutex);
diff --git a/src/3rdparty/webkit/JavaScriptCore/wtf/FastMalloc.cpp b/src/3rdparty/webkit/JavaScriptCore/wtf/FastMalloc.cpp
--- a/src/3rdparty/webkit/JavaScriptCore/wtf/FastMalloc.cpp
+++ b/src/3rdparty/webkit/JavaScriptCore/wtf/FastMalloc.cpp
@@ -97,7 +97,7 @@
 
 // Use a background thread to periodically scavenge memory to release back to the system
 // https://bugs.webkit.org/show_bug.cgi?id=27900: don't turn this on for Tiger until we have figured out why it caused a crash.
-#if defined(BUILDING_ON_TIGER)
+#if defined(BUILDING_ON_TIGER) || OS(GENODE)
 #define USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY 0
 #else
 #define USE_BACKGROUND_THREAD_TO_SCAVENGE_MEMORY 1
diff --git a/src/3rdparty/webkit/JavaScriptCore/wtf/Platform.h b/src/3rdparty/webkit/JavaScriptCore/wtf/Platform.h
--- a/src/3rdparty/webkit/JavaScriptCore/wtf/Platform.h
+++ b/src/3rdparty/webkit/JavaScriptCore/wtf/Platform.h
@@ -427,6 +427,13 @@
 #define WTF_OS_UNIX 1
 #endif
 
+/* OS(GENODE) */
+/* Operating system level dependencies for Genode that should */
+/* be used regardless of operating environment */
+#ifdef __GENODE__
+#define WTF_OS_GENODE 1
+#endif
+
 /* Operating environments */
 
 /* FIXME: these are all mixes of OS, operating environment and policy choices. */
@@ -679,13 +686,13 @@
 #endif
 #endif /* !defined(HAVE_ACCESSIBILITY) */
 
-#if OS(UNIX) && !OS(SYMBIAN)
+#if OS(UNIX) && !OS(SYMBIAN) && !OS(GENODE)
 #define HAVE_SIGNAL_H 1
 #endif
 
 #if !OS(WINDOWS) && !OS(SOLARIS) && !OS(QNX) \
     && !OS(SYMBIAN) && !OS(HAIKU) && !OS(RVCT) \
-    && !OS(ANDROID) && !PLATFORM(BREWMP)
+    && !OS(ANDROID) && !PLATFORM(BREWMP) && !OS(GENODE)
 #define HAVE_TM_GMTOFF 1
 #define HAVE_TM_ZONE 1
 #define HAVE_TIMEGM 1
@@ -764,6 +771,12 @@
 #define HAVE_SYS_PARAM_H 1
 #define HAVE_SYS_TIME_H 1
 
+#elif OS(GENODE)
+
+#define HAVE_MMAP 0
+#define HAVE_SBRK 0
+#define HAVE_SYS_TIME_H 1
+
 #else
 
 /* FIXME: is this actually used or do other platforms generate their own config.h? */
@@ -933,7 +946,7 @@
 #elif CPU(X86) && OS(WINDOWS) && COMPILER(MSVC)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_REGISTER 1
-#elif CPU(X86) && OS(LINUX) && GCC_VERSION >= 40100
+#elif CPU(X86) && OS(LINUX) && GCC_VERSION >= 40100 && !OS(GENODE)
     #define ENABLE_JIT 1
     #define WTF_USE_JIT_STUB_ARGUMENT_VA_LIST 1
 #elif CPU(X86_64) && OS(LINUX) && GCC_VERSION >= 40100
diff --git a/src/3rdparty/webkit/JavaScriptCore/wtf/TCSystemAlloc.cpp b/src/3rdparty/webkit/JavaScriptCore/wtf/TCSystemAlloc.cpp
--- a/src/3rdparty/webkit/JavaScriptCore/wtf/TCSystemAlloc.cpp
+++ b/src/3rdparty/webkit/JavaScriptCore/wtf/TCSystemAlloc.cpp
@@ -56,6 +56,12 @@
 #include <sys/mman.h>
 #endif
 
+#if OS(GENODE)
+#include <base/printf.h>
+#include <base/stdint.h>
+#include <util/misc_math.h>
+#endif
+
 #ifndef MAP_ANONYMOUS
 #define MAP_ANONYMOUS MAP_ANON
 #endif
@@ -379,6 +385,21 @@
     }
 #endif
 
+#if OS(GENODE)
+    if (actual_size)
+      *actual_size = size;
+
+    void* real_address = malloc(sizeof(Genode::addr_t) + size + alignment);
+    Genode::addr_t address = reinterpret_cast<Genode::addr_t>(real_address);
+    address += sizeof(Genode::addr_t);
+    address = Genode::align_addr(address, Genode::log2(alignment));
+    address -= sizeof(Genode::addr_t);
+    *(Genode::addr_t*)address = (Genode::addr_t)real_address;
+    address += sizeof(Genode::addr_t);
+
+    return (void*)address;;
+#endif
+
     // nothing worked - reset failure flags and try again
     devmem_failure = false;
     sbrk_failure = false;
diff --git a/src/corelib/codecs/qtextcodec.cpp b/src/corelib/codecs/qtextcodec.cpp
--- a/src/corelib/codecs/qtextcodec.cpp
+++ b/src/corelib/codecs/qtextcodec.cpp
@@ -91,7 +91,7 @@
 #include <langinfo.h>
 #endif
 
-#if defined(Q_OS_WINCE)
+#if defined(Q_OS_WINCE) || defined(Q_OS_GENODE)
 #  define QT_NO_SETLOCALE
 #endif
 
diff --git a/src/corelib/global/qglobal.cpp b/src/corelib/global/qglobal.cpp
--- a/src/corelib/global/qglobal.cpp
+++ b/src/corelib/global/qglobal.cpp
@@ -89,6 +89,10 @@
 _LIT(qt_symbianSystemInstallDir, "z:\\system\\install\\");
 #endif
 
+#if defined(Q_OS_GENODE)
+#include <base/printf.h>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 
@@ -2253,6 +2257,8 @@
             RDebug::Print(format, hbuffer);
         }
         delete hbuffer;
+#elif defined(Q_OS_GENODE)
+        PDBG("%s", buf);
 #else
         fprintf(stderr, "%s\n", buf);
         fflush(stderr);
diff --git a/src/corelib/global/qglobal.h b/src/corelib/global/qglobal.h
--- a/src/corelib/global/qglobal.h
+++ b/src/corelib/global/qglobal.h
@@ -143,6 +143,7 @@
 /*
    The operating system, must be one of: (Q_OS_x)
 
+     GENODE   - Genode
      DARWIN   - Darwin OS (synonym for Q_OS_MAC)
      SYMBIAN  - Symbian
      MSDOS    - MS-DOS and Windows
@@ -175,7 +176,9 @@
      UNIX     - Any UNIX BSD/SYSV system
 */
 
-#if defined(__APPLE__) && (defined(__GNUC__) || defined(__xlC__) || defined(__xlc__))
+#if defined(__GENODE__)
+#  define Q_OS_GENODE
+#elif defined(__APPLE__) && (defined(__GNUC__) || defined(__xlC__) || defined(__xlc__))
 #  define Q_OS_DARWIN
 #  define Q_OS_BSD4
 #  ifdef __LP64__
diff --git a/src/corelib/io/qprocess.cpp b/src/corelib/io/qprocess.cpp
--- a/src/corelib/io/qprocess.cpp
+++ b/src/corelib/io/qprocess.cpp
@@ -100,6 +100,10 @@
 #ifdef Q_OS_SYMBIAN
 #include <e32std.h>
 #endif
+#ifdef Q_OS_GENODE
+#include <rom_session/connection.h>
+#include <util/xml_node.h>
+#endif
 
 #ifndef QT_NO_PROCESS
 
@@ -762,6 +766,65 @@
     symbianProcess = NULL;
     processLaunched = false;
 #endif
+#ifdef Q_OS_GENODE
+    launchpad_child = 0;
+
+    /* request config file from ROM service */
+    Genode::Rom_connection rom("config");
+    rom.on_destruction(Genode::Rom_connection::KEEP_OPEN);
+    void *addr;
+    try {
+        addr = Genode::env()->rm_session()->attach(rom.dataspace());
+    } catch(Genode::Parent::Service_denied) {
+        qWarning("Error: Couldn't open config file.");
+        return;
+    }
+
+    /* 
+     * The XML data of a valid config file starts with 
+     * a <config> tag. 
+     */
+    Genode::Xml_node config_node((const char *)addr);
+
+    if (!config_node.has_type("config")) {
+        qWarning("Error: Root node of config file is not a <config> tag.");
+        return;
+    }
+
+    /* 
+     * Iterate through all entries of the config file and start 
+     * children as specified. 
+     */
+    for (int i = 0; i < config_node.num_sub_nodes(); i++) {
+        Genode::Xml_node program_node = config_node.sub_node(i);
+        if (program_node.has_type("program")) {
+
+            /* add filename and ram_quota to ram_quota_hash */
+            char filename[32];
+            try {
+                program_node.sub_node("filename").value(filename, sizeof(filename));
+            } catch (Genode::Xml_node::Nonexistent_sub_node) {
+                qWarning("Warning: Missing valid <filename> in config-file entry.");
+                return;
+            }
+
+            size_t ram_quota = 0;
+            try {
+                program_node.sub_node("ram_quota").value(&ram_quota);
+            } catch (Genode::Xml_node::Nonexistent_sub_node) {
+                qWarning("Warning: Missing valid <ram_quota> in config-file entry.");
+                return;
+            }
+
+            ram_quota_hash()->insert(QString(filename), ram_quota);
+        } else {
+            char buf[32];
+            program_node.type_name(buf, sizeof(buf));
+            qWarning("Warning: Ignoring unsupported tag <%s>.", buf);
+        }
+    }
+
+#endif
 }
 
 /*! \internal
diff --git a/src/corelib/io/qprocess_p.h b/src/corelib/io/qprocess_p.h
--- a/src/corelib/io/qprocess_p.h
+++ b/src/corelib/io/qprocess_p.h
@@ -71,6 +71,11 @@
 
 #ifndef QT_NO_PROCESS
 
+#ifdef Q_OS_GENODE
+#include <base/env.h>
+#include <launchpad/launchpad.h>
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QSocketNotifier;
@@ -96,6 +101,28 @@
     QStringList toList() const;
 };
 
+#ifdef Q_OS_GENODE
+
+class QProcess_launchpad : public Launchpad
+{
+public:
+    QProcess_launchpad(unsigned long initial_quota) : Launchpad(initial_quota) {}
+
+    virtual void quota(unsigned long quota) {}
+
+    virtual void add_launcher(const char *filename,
+                              unsigned long default_quota) {}
+
+    virtual void add_child(const char *unique_name,
+                           unsigned long quota,
+                           Launchpad_child *launchpad_child,
+                           Genode::Allocator *alloc) {}
+
+    virtual void remove_child(const char *name, Genode::Allocator *alloc) {}
+};
+
+#endif
+
 class QProcessPrivate : public QIODevicePrivate
 {
 public:
@@ -203,7 +230,7 @@
     QWinEventNotifier *processFinishedNotifier;
 
     void startProcess();
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined(Q_OS_GENODE)
     void execChild(const char *workingDirectory, char **path, char **argv, char **envp);
 #endif
     bool processStarted();
@@ -228,6 +255,22 @@
     int serial;
 #endif
 
+#ifdef Q_OS_GENODE
+    static QProcess_launchpad *launchpad()
+    {
+      static QProcess_launchpad _launchpad(Genode::env()->ram_session()->quota());
+      return &_launchpad;
+    }
+
+    static QHash<QString, size_t> *ram_quota_hash()
+    {
+        static QHash<QString, size_t> _ram_quota_hash;
+        return &_ram_quota_hash;
+    }
+
+    Launchpad_child *launchpad_child;
+#endif
+
     bool waitForStarted(int msecs = 30000);
     bool waitForReadyRead(int msecs = 30000);
     bool waitForBytesWritten(int msecs = 30000);
diff --git a/src/corelib/io/qresource.cpp b/src/corelib/io/qresource.cpp
--- a/src/corelib/io/qresource.cpp
+++ b/src/corelib/io/qresource.cpp
@@ -928,7 +928,7 @@
     }
 };
 
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined(Q_OS_GENODE)
 #define QT_USE_MMAP
 #endif
 
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -76,7 +76,11 @@
 #  if !defined(QT_NO_GLIB)
 #    include "qeventdispatcher_glib_p.h"
 #  endif
+#  ifdef Q_OS_GENODE
+#  include "qeventdispatcher_genode_p.h"
+#  else
 #  include "qeventdispatcher_unix_p.h"
+#  endif
 #endif
 
 #ifdef Q_OS_WIN
@@ -374,7 +378,11 @@
         eventDispatcher = new QEventDispatcherGlib(q);
     else
 #  endif
+#  ifdef Q_OS_GENODE
+        eventDispatcher = new QEventDispatcherGenode(q);
+#  else
         eventDispatcher = new QEventDispatcherUNIX(q);
+#  endif
 #elif defined(Q_OS_WIN)
     eventDispatcher = new QEventDispatcherWin32(q);
 #else
@@ -587,7 +595,7 @@
 {
     Q_D(QCoreApplication);
 
-#ifdef Q_OS_UNIX
+#if defined(Q_OS_UNIX) && !defined(Q_OS_GENODE)
     setlocale(LC_ALL, "");                // use correct char set mapping
     qt_locale_initialized = true;
 #endif
diff --git a/src/corelib/kernel/qtranslator.cpp b/src/corelib/kernel/qtranslator.cpp
--- a/src/corelib/kernel/qtranslator.cpp
+++ b/src/corelib/kernel/qtranslator.cpp
@@ -56,7 +56,7 @@
 #include "qhash.h"
 #include "qtranslator_p.h"
 
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined(Q_OS_GENODE)
 #define QT_USE_MMAP
 #include "private/qcore_unix_p.h"
 #endif
diff --git a/src/corelib/plugin/qpluginloader.cpp b/src/corelib/plugin/qpluginloader.cpp
--- a/src/corelib/plugin/qpluginloader.cpp
+++ b/src/corelib/plugin/qpluginloader.cpp
@@ -53,7 +53,7 @@
 # include "private/qcore_symbian_p.h"
 #endif
 
-#ifndef QT_NO_LIBRARY
+#if !defined(QT_NO_LIBRARY) || defined(Q_OS_GENODE)
 
 QT_BEGIN_NAMESPACE
 
@@ -139,7 +139,11 @@
     Constructs a plugin loader with the given \a parent.
 */
 QPluginLoader::QPluginLoader(QObject *parent)
-    : QObject(parent), d(0), did_load(false)
+    : QObject(parent),
+#ifndef Q_OS_GENODE
+      d(0),
+#endif
+      did_load(false)
 {
 }
 
@@ -157,7 +161,11 @@
     \sa setFileName()
 */
 QPluginLoader::QPluginLoader(const QString &fileName, QObject *parent)
-    : QObject(parent), d(0), did_load(false)
+    : QObject(parent),
+#ifndef Q_OS_GENODE
+      d(0),
+#endif
+      did_load(false)
 {
     setFileName(fileName);
 }
@@ -172,8 +180,10 @@
 */
 QPluginLoader::~QPluginLoader()
 {
+#ifndef Q_OS_GENODE
     if (d)
         d->release();
+#endif
 }
 
 /*!
@@ -200,8 +210,10 @@
 {
     if (!load())
         return 0;
+#ifndef Q_OS_GENODE
     if (d->instance)
         return d->instance();
+#endif
     return 0;
 }
 
@@ -217,6 +229,7 @@
 */
 bool QPluginLoader::load()
 {
+#ifndef Q_OS_GENODE
     if (!d || d->fileName.isEmpty())
         return false;
     if (did_load)
@@ -225,6 +238,9 @@
         return false;
     did_load = true;
     return d->loadPlugin();
+#else
+    return false;
+#endif
 }
 
 
@@ -246,12 +262,14 @@
 */
 bool QPluginLoader::unload()
 {
+#ifndef Q_OS_GENODE
     if (did_load) {
         did_load = false;
         return d->unload();
     }
     if (d)  // Ouch
         d->errorString = tr("The plugin was not loaded.");
+#endif
     return false;
 }
 
@@ -262,7 +280,11 @@
  */
 bool QPluginLoader::isLoaded() const
 {
+#ifndef Q_OS_GENODE
     return d && d->pHnd && d->instance;
+#else
+    return false;
+#endif
 }
 
 /*!
@@ -285,6 +307,7 @@
 */
 void QPluginLoader::setFileName(const QString &fileName)
 {
+#ifndef Q_OS_GENODE
 #if defined(QT_SHARED)
     QLibrary::LoadHints lh;
     if (d) {
@@ -348,13 +371,17 @@
     }
     Q_UNUSED(fileName);
 #endif
+#endif
 }
 
 QString QPluginLoader::fileName() const
 {
+#ifndef Q_OS_GENODE
     if (d)
         return d->fileName;
+#else
     return QString();
+#endif
 }
 
 /*!
@@ -364,7 +391,11 @@
 */
 QString QPluginLoader::errorString() const
 {
+#ifndef Q_OS_GENODE
     return (!d || d->errorString.isEmpty()) ? tr("Unknown error") : d->errorString;
+#else
+    return QString();
+#endif
 }
 
 typedef QList<QtPluginInstanceFunction> StaticInstanceFunctionList;
@@ -383,7 +414,7 @@
 
     \sa QLibrary::loadHints
 */
-
+#ifndef Q_OS_GENODE
 void QPluginLoader::setLoadHints(QLibrary::LoadHints loadHints)
 {
     if (!d) {
@@ -402,7 +433,7 @@
     }
     return d->loadHints;
 }
-
+#endif
 /*!
     \relates QPluginLoader
     \since 4.4
diff --git a/src/corelib/plugin/qpluginloader.h b/src/corelib/plugin/qpluginloader.h
--- a/src/corelib/plugin/qpluginloader.h
+++ b/src/corelib/plugin/qpluginloader.h
@@ -49,21 +49,23 @@
 #pragma message("QT_NO_LIBRARY is not supported on Windows")
 #endif
 
-#ifndef QT_NO_LIBRARY
+#if !defined(QT_NO_LIBRARY) || defined(Q_OS_GENODE) 
 
 QT_BEGIN_HEADER
 
 QT_BEGIN_NAMESPACE
 
 QT_MODULE(Core)
-
+#ifndef Q_OS_GENODE
 class QLibraryPrivate;
-
+#endif
 class Q_CORE_EXPORT QPluginLoader : public QObject
 {
     Q_OBJECT
     Q_PROPERTY(QString fileName READ fileName WRITE setFileName)
+#ifndef Q_OS_GENODE
     Q_PROPERTY(QLibrary::LoadHints loadHints READ loadHints WRITE setLoadHints)
+#endif
 public:
     explicit QPluginLoader(QObject *parent = 0);
     explicit QPluginLoader(const QString &fileName, QObject *parent = 0);
@@ -81,12 +83,15 @@
     QString fileName() const;
 
     QString errorString() const;
-
+#ifndef Q_OS_GENODE
     void setLoadHints(QLibrary::LoadHints loadHints);
     QLibrary::LoadHints loadHints() const;
+#endif
 
 private:
+#ifndef Q_OS_GENODE
     QLibraryPrivate *d;
+#endif
     bool did_load;
     Q_DISABLE_COPY(QPluginLoader)
 };
diff --git a/src/corelib/thread/qmutex_p.h b/src/corelib/thread/qmutex_p.h
--- a/src/corelib/thread/qmutex_p.h
+++ b/src/corelib/thread/qmutex_p.h
@@ -59,6 +59,12 @@
 
 QT_BEGIN_NAMESPACE
 
+#include <qplatformdefs.h>
+
+#ifdef Q_OS_GENODE
+#include <os/timed_semaphore.h>
+#endif
+
 class QMutexPrivate {
 public:
     QMutexPrivate(QMutex::RecursionMode mode);
@@ -74,10 +80,12 @@
     Qt::HANDLE owner;
     uint count;
 
-#if defined(Q_OS_UNIX)
+#if defined(Q_OS_UNIX) && !defined(Q_OS_GENODE)
     volatile bool wakeup;
     pthread_mutex_t mutex;
     pthread_cond_t cond;
+#elif defined(Q_OS_GENODE)
+    Genode::Timed_semaphore sem;
 #elif defined(Q_OS_WIN32) || defined(Q_OS_WINCE)
     HANDLE event;
 #endif
diff --git a/src/corelib/thread/qthread.cpp b/src/corelib/thread/qthread.cpp
--- a/src/corelib/thread/qthread.cpp
+++ b/src/corelib/thread/qthread.cpp
@@ -150,8 +150,10 @@
 QAdoptedThread::~QAdoptedThread()
 {
 #ifndef QT_NO_THREAD
+#ifndef Q_OS_GENODE
     QThreadPrivate::finish(this);
 #endif
+#endif
     // fprintf(stderr, "~QAdoptedThread = %p\n", this);
 }
 
@@ -177,7 +179,12 @@
       stackSize(0), priority(QThread::InheritPriority), data(d)
 {
 #if defined (Q_OS_UNIX)
+#ifdef Q_OS_GENODE
+		thread_id = 0;
+		genode_thread = 0;
+#else
     thread_id = 0;
+#endif
 #elif defined (Q_WS_WIN)
     handle = 0;
     id = 0;
diff --git a/src/corelib/thread/qthread_p.h b/src/corelib/thread/qthread_p.h
--- a/src/corelib/thread/qthread_p.h
+++ b/src/corelib/thread/qthread_p.h
@@ -54,6 +54,10 @@
 //
 //
 
+#ifdef Q_OS_GENODE
+#include <thread_qt.h>
+#endif
+
 #include "qplatformdefs.h"
 #include "QtCore/qthread.h"
 #include "QtCore/qmutex.h"
@@ -136,6 +140,56 @@
     static QThread *threadForId(int id);
 
 #ifdef Q_OS_UNIX
+#ifdef Q_OS_GENODE
+
+    class Genode_thread : public Genode::Thread_qt
+    {
+        private:
+
+    	    /*
+    	     * The '_finished_lock' is necessary because 'QThreadPrivate::mutex'
+    	     * uses a 'Genode::Timed_semaphore' internally and it isn't safe
+    	     * to delete a Genode thread that just called 'Semaphore::up()',
+    	     * because the 'Semaphore::_meta_lock' could still be locked.
+    	     */
+            Genode::Lock _finished_lock;
+            QThread *_qthread;
+
+        public:
+
+            Genode_thread(QThread *qthread)
+            : _finished_lock(Genode::Lock::LOCKED),
+              _qthread(qthread) { }
+
+            virtual void entry()
+            {
+                QThreadPrivate::start(_qthread);
+                QThreadPrivate::finish(_qthread);
+                _finished_lock.unlock();
+            }
+
+            void join()
+            {
+                _finished_lock.lock();
+            }
+    };
+
+    Genode_thread *genode_thread;
+
+    struct tls_struct {
+      QThreadData *data;
+      bool termination_enabled;
+    };
+
+    static QHash<Qt::HANDLE, struct tls_struct> tls;
+
+    Qt::HANDLE thread_id;
+    QWaitCondition thread_done;
+
+    static void start(QThread *thr);
+    static void finish(QThread *thr);
+
+#else // Q_OS_UNIX && !Q_OS_GENODE
     pthread_t thread_id;
     QWaitCondition thread_done;
 
@@ -145,6 +199,7 @@
 #else
     static void finish(void *);
 #endif
+#endif // Q_OS_GENODE
 #endif // Q_OS_UNIX
 
 #if defined(Q_OS_WIN32) || defined(Q_OS_WINCE)
diff --git a/src/corelib/tools/qdatetime.cpp b/src/corelib/tools/qdatetime.cpp
--- a/src/corelib/tools/qdatetime.cpp
+++ b/src/corelib/tools/qdatetime.cpp
@@ -3086,6 +3086,9 @@
     // posix compliant system
     struct timeval tv;
     gettimeofday(&tv, 0);
+#ifdef Q_OS_GENODE
+    ct.mds = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+#else
     time_t ltime = tv.tv_sec;
     struct tm *t = 0;
 
@@ -3100,6 +3103,7 @@
     Q_CHECK_PTR(t);
 
     ct.mds = msecsFromDecomposed(t->tm_hour, t->tm_min, t->tm_sec, tv.tv_usec / 1000);
+#endif /* Q_OS_GENODE */
     return ct;
 }
 
@@ -3984,6 +3988,10 @@
 
 static QDateTimePrivate::Spec utcToLocal(QDate &date, QTime &time)
 {
+#ifdef Q_OS_GENODE
+    /* no timezones in Genode */
+    return QDateTimePrivate::LocalUnknown;
+#endif
     QDate fakeDate = adjustDate(date);
 
     // won't overflow because of fakeDate
@@ -4058,6 +4066,10 @@
 
 static void localToUtc(QDate &date, QTime &time, int isdst)
 {
+#ifdef Q_OS_GENODE
+    /* no timezones in Genode */
+    return;
+#endif
     if (!date.isValid())
         return;
 
diff --git a/src/gui/embedded/qscreendriverfactory_qws.cpp b/src/gui/embedded/qscreendriverfactory_qws.cpp
--- a/src/gui/embedded/qscreendriverfactory_qws.cpp
+++ b/src/gui/embedded/qscreendriverfactory_qws.cpp
@@ -47,6 +47,9 @@
 #include "qscreentransformed_qws.h"
 #include "qscreenvfb_qws.h"
 #include "qscreenmulti_qws_p.h"
+#ifdef Q_OS_GENODE
+#include "qscreennitpicker_qws.h"
+#endif
 #include "qscreenqnx_qws.h"
 #include <stdlib.h>
 #include "private/qfactoryloader_p.h"
@@ -136,6 +139,12 @@
     if (driver == QLatin1String("multi"))
         return new QMultiScreen(displayId);
 #endif
+#ifdef Q_OS_GENODE
+#ifndef QT_NO_QWS_NITPICKER
+    if (driver == QLatin1String("nitpicker") || driver.isEmpty())
+        return new QNitpickerScreen(displayId);
+#endif
+#endif
 #if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
 #ifndef QT_NO_LIBRARY
 
@@ -174,6 +183,11 @@
 #ifndef QT_NO_QWS_MULTISCREEN
     list << QLatin1String("Multi");
 #endif
+#ifdef Q_OS_GENODE
+#ifndef QT_NO_QWS_NITPICKER
+    list << QLatin1String("Nitpicker");
+#endif
+#endif
 
 #if !defined(Q_OS_WIN32) || defined(QT_MAKEDLL)
 #ifndef QT_NO_LIBRARY
diff --git a/src/gui/embedded/qwindowsystem_qws.cpp b/src/gui/embedded/qwindowsystem_qws.cpp
--- a/src/gui/embedded/qwindowsystem_qws.cpp
+++ b/src/gui/embedded/qwindowsystem_qws.cpp
@@ -3362,8 +3362,15 @@
 void QWSServerPrivate::raiseWindow(QWSWindow *changingw, int /*alt*/)
 {
     Q_Q(QWSServer);
-    if (changingw == windows.first())
+
+    if (changingw == windows.first()) {
+#ifndef QT_NO_QWS_NITPICKER
+        // make sure that the Nitpicker view is on top, too
+        emit q->windowEvent(changingw, QWSServer::Raise);
+#endif
         return;
+    }
+
     QWSWindow::State oldstate = changingw->d->state;
     changingw->d->state = QWSWindow::Raising;
     // Expose regions previously overlapped by transparent windows
diff --git a/src/gui/image/qpnghandler.cpp b/src/gui/image/qpnghandler.cpp
--- a/src/gui/image/qpnghandler.cpp
+++ b/src/gui/image/qpnghandler.cpp
@@ -174,7 +174,7 @@
     }
 }
 
-
+#ifdef PNG_WRITE_SUPPORTED
 static
 void CALLBACK_CALL_TYPE qpiw_write_fn(png_structp png_ptr, png_bytep data, png_size_t length)
 {
@@ -193,6 +193,7 @@
 void CALLBACK_CALL_TYPE qpiw_flush_fn(png_structp /* png_ptr */)
 {
 }
+#endif
 
 #if defined(Q_C_CALLBACKS)
 }
@@ -201,12 +202,13 @@
 static
 void setup_qt(QImage& image, png_structp png_ptr, png_infop info_ptr, float screen_gamma=0.0)
 {
+#if defined(PNG_gAMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
     if (screen_gamma != 0.0 && png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA)) {
         double file_gamma;
         png_get_gAMA(png_ptr, info_ptr, &file_gamma);
         png_set_gamma(png_ptr, screen_gamma, file_gamma);
     }
-
+#endif
     png_uint_32 width;
     png_uint_32 height;
     int bit_depth;
@@ -384,13 +386,13 @@
         png_ptr = 0;
         return false;
     }
-
+#ifdef PNG_SETJMP_SUPPORTED
     if (setjmp(png_jmpbuf(png_ptr))) {
         png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
         png_ptr = 0;
         return false;
     }
-
+#endif
     png_set_read_fn(png_ptr, this, iod_read_fn);
     png_read_info(png_ptr, info_ptr);
 
@@ -442,6 +444,7 @@
     }
 
     row_pointers = 0;
+#ifdef PNG_SETJMP_SUPPORTED
     if (setjmp(png_jmpbuf(png_ptr))) {
         png_destroy_read_struct(&png_ptr, &info_ptr, &end_info);
         delete [] row_pointers;
@@ -449,7 +452,7 @@
         state = Error;
         return false;
     }
-
+#endif
     setup_qt(*outImage, png_ptr, info_ptr, gamma);
 
     if (outImage->isNull()) {
@@ -480,9 +483,9 @@
     png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)
         if (outImage->depth()==32 && png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS)) {
             QRgb trans = 0xFF000000 | qRgb(
-                (info_ptr->trans_values.red << 8 >> bit_depth)&0xff,
-                (info_ptr->trans_values.green << 8 >> bit_depth)&0xff,
-                (info_ptr->trans_values.blue << 8 >> bit_depth)&0xff);
+                (info_ptr->trans_color.red << 8 >> bit_depth)&0xff,
+                (info_ptr->trans_color.green << 8 >> bit_depth)&0xff,
+                (info_ptr->trans_color.blue << 8 >> bit_depth)&0xff);
             for (uint y=0; y<height; y++) {
                 for (uint x=0; x<info_ptr->width; x++) {
                     if (((uint**)jt)[y][x] == trans) {
@@ -620,7 +623,7 @@
     gamma = g;
 }
 
-
+#ifdef PNG_WRITE_SUPPORTED
 #ifndef QT_NO_IMAGE_TEXT
 static void set_text(const QImage &image, png_structp png_ptr, png_infop info_ptr,
                      const QString &description)
@@ -685,6 +688,7 @@
     delete [] text_ptr;
 }
 #endif
+#endif
 
 bool QPNGImageWriter::writeImage(const QImage& image, int off_x, int off_y)
 {
@@ -694,6 +698,8 @@
 bool Q_INTERNAL_WIN_NO_THROW QPNGImageWriter::writeImage(const QImage& image, int quality_in, const QString &description,
                                  int off_x_in, int off_y_in)
 {
+#ifdef PNG_WRITE_SUPPORTED
+
 #ifdef QT_NO_IMAGE_TEXT
     Q_UNUSED(description);
 #endif
@@ -717,12 +723,12 @@
         png_destroy_write_struct(&png_ptr, 0);
         return false;
     }
-
+#ifdef PNG_SETJMP_SUPPORTED
     if (setjmp(png_jmpbuf(png_ptr))) {
         png_destroy_write_struct(&png_ptr, &info_ptr);
         return false;
     }
-
+#endif
     int quality = quality_in;
     if (quality >= 0) {
         if (quality > 9) {
@@ -747,9 +753,11 @@
                  image.depth() == 1 ? 1 : 8, // per channel
                  color_type, 0, 0, 0);       // sets #channels
 
+#if defined(PNG_gAMA_SUPPORTED) && defined(PNG_FLOATING_POINT_SUPPORTED)
     if (gamma != 0.0) {
         png_set_gAMA(png_ptr, info_ptr, 1.0/gamma);
     }
+#endif
 
     png_color_8 sig_bit;
     sig_bit.red = 8;
@@ -875,6 +883,9 @@
     png_destroy_write_struct(&png_ptr, &info_ptr);
 
     return true;
+#else
+		return false;
+#endif
 }
 
 static bool write_png_image(const QImage &image, QIODevice *device,
diff --git a/src/gui/image/qxpmhandler.cpp b/src/gui/image/qxpmhandler.cpp
--- a/src/gui/image/qxpmhandler.cpp
+++ b/src/gui/image/qxpmhandler.cpp
@@ -866,8 +866,16 @@
 #if defined(_MSC_VER) && _MSC_VER >= 1400 && !defined(Q_OS_WINCE)
         if (sscanf_s(buf, "%d %d %d %d", w, h, ncols, cpp) < 4)
 #else
+#ifdef Q_OS_GENODE
+    *w = QString(buf).section(" ", 0, 0, QString::SectionSkipEmpty).toInt();
+    *h = QString(buf).section(" ", 1, 1, QString::SectionSkipEmpty).toInt();
+    *ncols = QString(buf).section(" ", 2, 2, QString::SectionSkipEmpty).toInt();
+    *cpp = QString(buf).section(" ", 3, 3, QString::SectionSkipEmpty).toInt();
+    if (*w <= 0 || *h <= 0 || *ncols <= 0 || *cpp <= 0)
+#else
     if (sscanf(buf, "%d %d %d %d", w, h, ncols, cpp) < 4)
 #endif
+#endif
         return false;                                        // < 4 numbers parsed
 
     return true;
diff --git a/src/gui/kernel/qapplication.cpp b/src/gui/kernel/qapplication.cpp
--- a/src/gui/kernel/qapplication.cpp
+++ b/src/gui/kernel/qapplication.cpp
@@ -728,11 +728,23 @@
 */
 
 QApplication::QApplication(int &argc, char **argv)
-    : QCoreApplication(*new QApplicationPrivate(argc, argv, GuiClient))
+    : QCoreApplication(*new QApplicationPrivate(argc, argv,
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      ))
 { Q_D(QApplication); d->construct(); }
 
 QApplication::QApplication(int &argc, char **argv, int _internal)
-    : QCoreApplication(*new QApplicationPrivate(argc, argv, GuiClient))
+    : QCoreApplication(*new QApplicationPrivate(argc, argv,
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      ))
 { Q_D(QApplication); d->construct(); QApplicationPrivate::app_compile_version = _internal;}
 
 
@@ -762,11 +774,23 @@
 */
 
 QApplication::QApplication(int &argc, char **argv, bool GUIenabled )
-    : QCoreApplication(*new QApplicationPrivate(argc, argv, GUIenabled ? GuiClient : Tty))
+    : QCoreApplication(*new QApplicationPrivate(argc, argv, GUIenabled ?
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      : Tty))
 { Q_D(QApplication); d->construct(); }
 
 QApplication::QApplication(int &argc, char **argv, bool GUIenabled , int _internal)
-    : QCoreApplication(*new QApplicationPrivate(argc, argv, GUIenabled ? GuiClient : Tty))
+    : QCoreApplication(*new QApplicationPrivate(argc, argv, GUIenabled ?
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      : Tty))
 { Q_D(QApplication); d->construct();  QApplicationPrivate::app_compile_version = _internal;}
 
 
@@ -896,7 +920,13 @@
     This function is only available on X11.
 */
 QApplication::QApplication(Display* dpy, Qt::HANDLE visual, Qt::HANDLE colormap)
-    : QCoreApplication(*new QApplicationPrivate(aargc, aargv, GuiClient))
+    : QCoreApplication(*new QApplicationPrivate(aargc, aargv,
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      ))
 {
     if (! dpy)
         qWarning("QApplication: Invalid Display* argument");
@@ -905,7 +935,13 @@
 }
 
 QApplication::QApplication(Display* dpy, Qt::HANDLE visual, Qt::HANDLE colormap, int _internal)
-    : QCoreApplication(*new QApplicationPrivate(aargc, aargv, GuiClient))
+    : QCoreApplication(*new QApplicationPrivate(aargc, aargv, 
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      ))
 {
     if (! dpy)
         qWarning("QApplication: Invalid Display* argument");
@@ -930,7 +966,13 @@
 */
 QApplication::QApplication(Display *dpy, int &argc, char **argv,
                            Qt::HANDLE visual, Qt::HANDLE colormap)
-    : QCoreApplication(*new QApplicationPrivate(argc, argv, GuiClient))
+    : QCoreApplication(*new QApplicationPrivate(argc, argv,
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      ))
 {
     if (! dpy)
         qWarning("QApplication: Invalid Display* argument");
@@ -940,7 +982,13 @@
 
 QApplication::QApplication(Display *dpy, int &argc, char **argv,
                            Qt::HANDLE visual, Qt::HANDLE colormap, int _internal)
-    : QCoreApplication(*new QApplicationPrivate(argc, argv, GuiClient))
+    : QCoreApplication(*new QApplicationPrivate(argc, argv, 
+#ifndef Q_OS_GENODE
+        GuiClient
+#else
+        GuiServer
+#endif
+      ))
 {
     if (! dpy)
         qWarning("QApplication: Invalid Display* argument");
diff --git a/src/gui/kernel/qapplication_qws.cpp b/src/gui/kernel/qapplication_qws.cpp
--- a/src/gui/kernel/qapplication_qws.cpp
+++ b/src/gui/kernel/qapplication_qws.cpp
@@ -203,7 +203,7 @@
         return result;
     result = QT_VFB_DATADIR(qws_display_id);
     QByteArray dataDir = result.toLocal8Bit();
-
+#ifndef Q_OS_GENODE
     if (QT_MKDIR(dataDir, 0700)) {
         if (errno != EEXIST) {
             qFatal("Cannot create Qt for Embedded Linux data directory: %s", dataDir.constData());
@@ -224,6 +224,7 @@
     if ((buf.st_mode & 0677) != 0600)
         qFatal("Qt for Embedded Linux data directory has incorrect permissions: %s", dataDir.constData());
 #endif
+#endif
 
     result.append("/");
     return result;
@@ -471,7 +472,11 @@
 #endif
     eventDispatcher = (q->type() != QApplication::Tty
                        ? new QEventDispatcherQWS(q)
+#ifdef Q_OS_GENODE
+                       : new QEventDispatcherGenode(q));
+#else
                        : new QEventDispatcherUNIX(q));
+#endif
 }
 
 // Single-process stuff. This should maybe move into qwindowsystem_qws.cpp
@@ -2894,9 +2899,15 @@
                 // The server has grabbed the mouse for us.
                 // Remember which of my widgets has it.
                 qt_pressGrab = w;
-                if (!widget->isActiveWindow() &&
+                if (
+#ifdef QT_NO_QWS_NITPICKER  // make sure that the Nitpicker view is on top, too
+                    !widget->isActiveWindow() &&
+#endif
                     (!app_do_modal || QApplication::activeModalWidget() == widget) &&
                     !((widget->windowFlags() & Qt::FramelessWindowHint) || (widget->windowType() == Qt::Tool))) {
+#ifndef QT_NO_QWS_NITPICKER
+                    if (!widget->isActiveWindow())
+#endif
                     widget->activateWindow();
                     if (widget->raiseOnClick())
                         widget->raise();
diff --git a/src/gui/kernel/qeventdispatcher_qws.cpp b/src/gui/kernel/qeventdispatcher_qws.cpp
--- a/src/gui/kernel/qeventdispatcher_qws.cpp
+++ b/src/gui/kernel/qeventdispatcher_qws.cpp
@@ -46,7 +46,11 @@
 #include "qwsevent_qws.h"
 #include "qwindowsystem_qws.h"
 #include "qeventdispatcher_qws_p.h"
+#ifdef Q_OS_GENODE
+#include "private/qeventdispatcher_genode_p.h"
+#else
 #include "private/qeventdispatcher_unix_p.h"
+#endif
 #ifndef QT_NO_THREAD
 #  include "qmutex.h"
 #endif
@@ -57,7 +61,11 @@
 
 QT_USE_NAMESPACE
 
+#ifdef Q_OS_GENODE
+class QEventDispatcherQWSPrivate : public QEventDispatcherGenodePrivate
+#else
 class QEventDispatcherQWSPrivate : public QEventDispatcherUNIXPrivate
+#endif
 {
     Q_DECLARE_PUBLIC(QEventDispatcherQWS)
 public:
@@ -68,7 +76,11 @@
 
 
 QEventDispatcherQWS::QEventDispatcherQWS(QObject *parent)
+#ifdef Q_OS_GENODE
+    : QEventDispatcherGenode(*new QEventDispatcherQWSPrivate, parent)
+#else
     : QEventDispatcherUNIX(*new QEventDispatcherQWSPrivate, parent)
+#endif
 { }
 
 QEventDispatcherQWS::~QEventDispatcherQWS()
@@ -129,7 +141,11 @@
             QWSServer::processEventQueue();
         }
 
+#ifdef Q_OS_GENODE
+        if (QEventDispatcherGenode::processEvents(flags))
+#else
         if (QEventDispatcherUNIX::processEvents(flags))
+#endif
             return true;
     }
     return (nevents > 0);
@@ -158,11 +174,11 @@
     (void)qt_fbdpy->eventPending(); // flush
 }
 
-
+#ifndef Q_OS_GENODE
 int QEventDispatcherQWS::select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                                 timeval *timeout)
 {
     return QEventDispatcherUNIX::select(nfds, readfds, writefds, exceptfds, timeout);
 }
-
+#endif
 QT_END_NAMESPACE
diff --git a/src/gui/kernel/qeventdispatcher_qws_p.h b/src/gui/kernel/qeventdispatcher_qws_p.h
--- a/src/gui/kernel/qeventdispatcher_qws_p.h
+++ b/src/gui/kernel/qeventdispatcher_qws_p.h
@@ -53,13 +53,23 @@
 // We mean it.
 //
 
+#include "qplatformdefs.h"
+
+#ifdef Q_OS_GENODE
+#include "private/qeventdispatcher_genode_p.h"
+#else
 #include "private/qeventdispatcher_unix_p.h"
+#endif
 
 QT_BEGIN_NAMESPACE
 
 class QEventDispatcherQWSPrivate;
 
+#ifdef Q_OS_GENODE
+class QEventDispatcherQWS : public QEventDispatcherGenode
+#else
 class QEventDispatcherQWS : public QEventDispatcherUNIX
+#endif
 {
     Q_OBJECT
     Q_DECLARE_PRIVATE(QEventDispatcherQWS)
@@ -77,8 +87,10 @@
     void closingDown();
 
 protected:
+#ifndef Q_OS_GENODE
     int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
                timeval *timeout);
+#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/gui/text/qfontdatabase_qws.cpp b/src/gui/text/qfontdatabase_qws.cpp
--- a/src/gui/text/qfontdatabase_qws.cpp
+++ b/src/gui/text/qfontdatabase_qws.cpp
@@ -382,12 +382,51 @@
 
     }
 #endif
-    QDir dir(fontpath, QLatin1String("*.qpf2"));
+
+    QDir dir(fontpath, QLatin1String("*.qpf"));
+    for (int i=0; i<int(dir.count()); i++) {
+        int u0 = dir[i].indexOf(QLatin1Char('_'));
+        int u1 = dir[i].indexOf(QLatin1Char('_'), u0+1);
+        int u2 = dir[i].indexOf(QLatin1Char('_'), u1+1);
+        int u3 = dir[i].indexOf(QLatin1Char('.'), u1+1);
+        if (u2 < 0) u2 = u3;
+
+        QString familyname = dir[i].left(u0);
+        int pixelSize = dir[i].mid(u0+1,u1-u0-1).toInt()/10;
+        bool italic = dir[i].mid(u2-1,1) == QLatin1String("i");
+        int weight = dir[i].mid(u1+1,u2-u1-1-(italic?1:0)).toInt();
+
+        db->addFont(familyname, /*foundry*/ "qt", weight, italic, pixelSize, QFile::encodeName(dir.absoluteFilePath(dir[i])),
+                    /*fileIndex*/ 0, /*antialiased*/ true);
+    }
+
+#ifndef QT_NO_FREETYPE
+    dir.setNameFilters(QStringList() << QLatin1String("*.ttf")
+                       << QLatin1String("*.ttc") << QLatin1String("*.pfa")
+                       << QLatin1String("*.pfb"));
+    dir.refresh();
+    for (int i = 0; i < int(dir.count()); ++i) {
+        const QByteArray file = QFile::encodeName(dir.absoluteFilePath(dir[i]));
+//        qDebug() << "looking at" << file;
+        QByteArray data;
+        QFile f(file);
+        if (!(f.fileEngine()->fileFlags(QAbstractFileEngine::FlagsMask) & QAbstractFileEngine::LocalDiskFlag)) {
+            if (!f.open(QIODevice::ReadOnly))
+                continue;
+            data = f.readAll();
+        }
+        db->addTTFile(file, data);
+    }
+#endif
+
+#ifndef QT_NO_QWS_QPF2
+    dir.setNameFilters(QStringList() << QLatin1String("*.qpf2"));
     for (int i = 0; i < int(dir.count()); ++i) {
         const QByteArray file = QFile::encodeName(dir.absoluteFilePath(dir[i]));
         //qDebug() << "looking at" << file;
         db->addQPF2File(file);
     }
+#endif
 #endif //QT_FONTS_ARE_RESOURCES
 
 
diff --git a/src/gui/text/qfontengine_qws.cpp b/src/gui/text/qfontengine_qws.cpp
--- a/src/gui/text/qfontengine_qws.cpp
+++ b/src/gui/text/qfontengine_qws.cpp
@@ -390,6 +390,23 @@
 {
     cache_cost = 1;
 
+#ifdef Q_OS_GENODE
+
+    QFile ff(fn);
+    if (!ff.open(QIODevice::ReadOnly)) {
+      qFatal("Failed to open %s", QFile::encodeName(fn).data());
+    }
+
+    uchar* data = new uchar[ff.size()];
+
+    for (int i = 0; i < ff.size(); i++) {
+      ff.getChar(reinterpret_cast<char*>(&data[i]));
+    }
+
+    ff.close();
+
+#else
+
     int f = QT_OPEN( QFile::encodeName(fn), O_RDONLY, 0);
     Q_ASSERT(f>=0);
     QT_STATBUF st;
@@ -411,9 +428,13 @@
         qFatal("Failed to mmap %s",QFile::encodeName(fn).data());
     QT_CLOSE(f);
 
+#endif /* Q_OS_GENODE */
+
     d = new QFontEngineQPF1Data;
+#ifndef Q_OS_GENODE
     d->mmapStart = data;
     d->mmapLength = st.st_size;
+#endif
     memcpy(reinterpret_cast<char*>(&d->fm),data,sizeof(d->fm));
 
     data += sizeof(d->fm);
diff --git a/src/network/access/qnetworkaccessfilebackend.cpp b/src/network/access/qnetworkaccessfilebackend.cpp
--- a/src/network/access/qnetworkaccessfilebackend.cpp
+++ b/src/network/access/qnetworkaccessfilebackend.cpp
@@ -106,6 +106,7 @@
         url.setPath(QLatin1String("/"));
     setUrl(url);
 
+#ifndef Q_OS_GENODE
     QString fileName = url.toLocalFile();
     if (fileName.isEmpty()) {
         if (url.scheme() == QLatin1String("qrc"))
@@ -113,6 +114,10 @@
         else
             fileName = url.toString(QUrl::RemoveAuthority | QUrl::RemoveFragment | QUrl::RemoveQuery);
     }
+#else
+    QString fileName = QLatin1String(":") + url.path();
+#endif
+
     file.setFileName(fileName);
 
     if (operation() == QNetworkAccessManager::GetOperation) {
diff --git a/src/network/kernel/qhostinfo_unix.cpp b/src/network/kernel/qhostinfo_unix.cpp
--- a/src/network/kernel/qhostinfo_unix.cpp
+++ b/src/network/kernel/qhostinfo_unix.cpp
@@ -148,6 +148,11 @@
     QHostAddress address;
     if (address.setAddress(hostName)) {
         // Reverse lookup
+#ifdef Q_OS_GENODE
+    results.setError(QHostInfo::HostNotFound);
+    results.setErrorString(tr("Reverse lookup is not implemented because of missing support in lwip."));
+    return results;
+#else
 // Reverse lookups using getnameinfo are broken on darwin, use gethostbyaddr instead.
 #if !defined (QT_NO_GETADDRINFO) && !defined (Q_OS_DARWIN) && !defined (Q_OS_SYMBIAN)
         sockaddr_in sa4;
@@ -182,7 +187,7 @@
         if (ent)
             results.setHostName(QString::fromLatin1(ent->h_name));
 #endif
-
+#endif
         if (results.hostName().isEmpty())
             results.setHostName(address.toString());
         results.setAddresses(QList<QHostAddress>() << address);
diff --git a/tools/designer/src/lib/uilib/formbuilder.cpp b/tools/designer/src/lib/uilib/formbuilder.cpp
--- a/tools/designer/src/lib/uilib/formbuilder.cpp
+++ b/tools/designer/src/lib/uilib/formbuilder.cpp
@@ -44,6 +44,8 @@
 #include "formbuilderextra_p.h"
 #include "ui4_p.h"
 
+#include "qpluginloader.h"
+
 #include <QtGui/QtGui>
 #include <QtCore/QCoreApplication>
 
@@ -493,7 +495,7 @@
 void QFormBuilder::updateCustomWidgets()
 {
     m_customWidgets.clear();
-
+#ifndef Q_OS_GENODE
     foreach (const QString &path, m_pluginPaths) {
         const QDir dir(path);
         const QStringList candidates = dir.entryList(QDir::Files);
@@ -511,6 +513,7 @@
                 insertPlugins(loader.instance(), &m_customWidgets);
         }
     }
+#endif
     // Check statically linked plugins
     const QObjectList staticPlugins = QPluginLoader::staticInstances();
     if (!staticPlugins.empty())
diff --git a/tools/designer/src/uitools/quiloader.cpp b/tools/designer/src/uitools/quiloader.cpp
--- a/tools/designer/src/uitools/quiloader.cpp
+++ b/tools/designer/src/uitools/quiloader.cpp
@@ -630,7 +630,7 @@
     Q_D(QUiLoader);
 
     d->builder.loader = this;
-
+#ifndef Q_OS_GENODE
     QStringList paths;
     foreach (const QString &path, QApplication::libraryPaths()) {
         QString libPath = path;
@@ -640,6 +640,7 @@
     }
 
     d->builder.setPluginPath(paths);
+#endif
 }
 
 /*!
